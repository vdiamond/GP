// This code was generated by the Gardens Point Parser Generator
// Copyright (c) Wayne Kelly, QUT 2005-2010
// (see accompanying GPPGcopyright.rtf)

// GPPG version 1.0.0.0
// Machine:  DESKTOP-DSDDFC5
// DateTime: 2020-08-01 11:25:03 AM
// UserName: victo
// Input file <RealCalc.y - 2020-08-01 11:23:04 AM>

// options: no-lines

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using QUT.Gputil;

internal enum Tokens {error=62,EOF=63,DIGIT=64,LETTER=65,UMINUS=66};

internal struct ValueType
{ public double dVal; 
         public char cVal; 
         public int iVal; }
internal class Parser: ShiftReduceParser<ValueType, LexLocation>
{
  // Verbatim content from RealCalc.y - 2020-08-01 11:23:04 AM
    double[] regs = new double[26];
    StringBuilder buffer = null;
  // End verbatim content from RealCalc.y - 2020-08-01 11:23:04 AM

#pragma warning disable 649
  private static Dictionary<int, string> aliasses;
#pragma warning restore 649
  private static Rule[] rules = new Rule[18];
  private static State[] states = new State[30];
  private static string[] nonTerms = new string[] {
      "list", "expr", "$accept", "stat", "number", };

  static Parser() {
    states[0] = new State(-2,new int[]{-1,1});
    states[1] = new State(new int[]{63,2,62,5,40,16,45,19,65,27,64,26},new int[]{-4,3,-2,7,-5,22});
    states[2] = new State(-1);
    states[3] = new State(new int[]{10,4});
    states[4] = new State(-3);
    states[5] = new State(new int[]{10,6});
    states[6] = new State(-4);
    states[7] = new State(new int[]{42,8,47,10,43,12,45,14,10,-5});
    states[8] = new State(new int[]{40,16,45,19,65,21,64,26},new int[]{-2,9,-5,22});
    states[9] = new State(-8);
    states[10] = new State(new int[]{40,16,45,19,65,21,64,26},new int[]{-2,11,-5,22});
    states[11] = new State(-9);
    states[12] = new State(new int[]{40,16,45,19,65,21,64,26},new int[]{-2,13,-5,22});
    states[13] = new State(new int[]{42,8,47,10,43,-10,45,-10,10,-10,41,-10});
    states[14] = new State(new int[]{40,16,45,19,65,21,64,26},new int[]{-2,15,-5,22});
    states[15] = new State(new int[]{42,8,47,10,43,-11,45,-11,10,-11,41,-11});
    states[16] = new State(new int[]{40,16,45,19,65,21,64,26},new int[]{-2,17,-5,22});
    states[17] = new State(new int[]{41,18,42,8,47,10,43,12,45,14});
    states[18] = new State(-7);
    states[19] = new State(new int[]{40,16,45,19,65,21,64,26},new int[]{-2,20,-5,22});
    states[20] = new State(-12);
    states[21] = new State(-13);
    states[22] = new State(new int[]{64,23,46,24,42,-14,47,-14,43,-14,45,-14,10,-14,41,-14});
    states[23] = new State(-16);
    states[24] = new State(new int[]{64,25});
    states[25] = new State(-17);
    states[26] = new State(-15);
    states[27] = new State(new int[]{61,28,42,-13,47,-13,43,-13,45,-13,10,-13});
    states[28] = new State(new int[]{40,16,45,19,65,21,64,26},new int[]{-2,29,-5,22});
    states[29] = new State(new int[]{42,8,47,10,43,12,45,14,10,-6});

    for (int sNo = 0; sNo < states.Length; sNo++) states[sNo].number = sNo;

    rules[1] = new Rule(-3, new int[]{-1,63});
    rules[2] = new Rule(-1, new int[]{});
    rules[3] = new Rule(-1, new int[]{-1,-4,10});
    rules[4] = new Rule(-1, new int[]{-1,62,10});
    rules[5] = new Rule(-4, new int[]{-2});
    rules[6] = new Rule(-4, new int[]{65,61,-2});
    rules[7] = new Rule(-2, new int[]{40,-2,41});
    rules[8] = new Rule(-2, new int[]{-2,42,-2});
    rules[9] = new Rule(-2, new int[]{-2,47,-2});
    rules[10] = new Rule(-2, new int[]{-2,43,-2});
    rules[11] = new Rule(-2, new int[]{-2,45,-2});
    rules[12] = new Rule(-2, new int[]{45,-2});
    rules[13] = new Rule(-2, new int[]{65});
    rules[14] = new Rule(-2, new int[]{-5});
    rules[15] = new Rule(-5, new int[]{64});
    rules[16] = new Rule(-5, new int[]{-5,64});
    rules[17] = new Rule(-5, new int[]{-5,46,64});
  }

  protected override void Initialize() {
    this.InitSpecialTokens((int)Tokens.error, (int)Tokens.EOF);
    this.InitStates(states);
    this.InitRules(rules);
    this.InitNonTerminals(nonTerms);
  }

  protected override void DoAction(int action)
  {
#pragma warning disable 162, 1522
    switch (action)
    {
      case 4: // list -> list, error, '\n'
{
                    yyerrok();
                }
        break;
      case 5: // stat -> expr
{
                    System.Console.WriteLine(ValueStack[ValueStack.Depth-1].dVal);
                }
        break;
      case 6: // stat -> LETTER, '=', expr
{
                    regs[ValueStack[ValueStack.Depth-3].iVal] = ValueStack[ValueStack.Depth-1].dVal;
                }
        break;
      case 7: // expr -> '(', expr, ')'
{
                    CurrentSemanticValue.dVal = ValueStack[ValueStack.Depth-2].dVal;
                }
        break;
      case 8: // expr -> expr, '*', expr
{
                    CurrentSemanticValue.dVal = ValueStack[ValueStack.Depth-3].dVal * ValueStack[ValueStack.Depth-1].dVal;
                }
        break;
      case 9: // expr -> expr, '/', expr
{
                    CurrentSemanticValue.dVal = ValueStack[ValueStack.Depth-3].dVal / ValueStack[ValueStack.Depth-1].dVal;
                }
        break;
      case 10: // expr -> expr, '+', expr
{
                    CurrentSemanticValue.dVal = ValueStack[ValueStack.Depth-3].dVal + ValueStack[ValueStack.Depth-1].dVal;
                }
        break;
      case 11: // expr -> expr, '-', expr
{
                    CurrentSemanticValue.dVal = ValueStack[ValueStack.Depth-3].dVal - ValueStack[ValueStack.Depth-1].dVal;
                }
        break;
      case 12: // expr -> '-', expr
{
                    CurrentSemanticValue.dVal = -ValueStack[ValueStack.Depth-1].dVal;
                }
        break;
      case 13: // expr -> LETTER
{
                    CurrentSemanticValue.dVal = regs[ValueStack[ValueStack.Depth-1].iVal];
                }
        break;
      case 14: // expr -> number
{
                    try {
                        CurrentSemanticValue.dVal = double.Parse(buffer.ToString());
                    } catch (FormatException) {
                        Scanner.yyerror("Illegal number \"{0}\"", buffer);
                    }
                }
        break;
      case 15: // number -> DIGIT
{ 
                   buffer = new StringBuilder();
                   buffer.Append(ValueStack[ValueStack.Depth-1].cVal);
               }
        break;
      case 16: // number -> number, DIGIT
{ 
                   buffer.Append(ValueStack[ValueStack.Depth-1].cVal);
               }
        break;
      case 17: // number -> number, '.', DIGIT
{ 
                   buffer.Append('.');
                   buffer.Append(ValueStack[ValueStack.Depth-1].cVal);
               }
        break;
    }
#pragma warning restore 162, 1522
  }

  protected override string TerminalToString(int terminal)
  {
    if (aliasses != null && aliasses.ContainsKey(terminal))
        return aliasses[terminal];
    else if (((Tokens)terminal).ToString() != terminal.ToString(CultureInfo.InvariantCulture))
        return ((Tokens)terminal).ToString();
    else
        return CharToString((char)terminal);
  }


/* 
 * GPPG does not create a default parser constructor
 * Most applications will have a parser type with other
 * fields such as error handlers etc.  Here is a minimal
 * version that just adds the default scanner object.
 */
Parser(Lexer s) : base(s) { }

static void Main(string[] args)
{    
    System.IO.TextReader reader;
    if (args.Length > 0)
        reader = new System.IO.StreamReader(args[0]);
    else
        reader = System.Console.In;
        
    Parser parser = new Parser( new Lexer( reader ));
    //parser.Trace = true;
    
    Console.WriteLine("RealCalc expression evaluator, type ^C to exit");
    parser.Parse();
}

/*
 *  Version for real arithmetic.  YYSTYPE is ValueType.
 */
class Lexer: QUT.Gputil.AbstractScanner<ValueType, LexLocation>
{
     private System.IO.TextReader reader;

     public Lexer(System.IO.TextReader reader)
     {
         this.reader = reader;
     }

     public override int yylex()
     {
         char ch;
         int ord = reader.Read();
         //
         // Must check for EOF
         //
         if (ord == -1)
             return (int)Tokens.EOF;
         else
             ch = (char)ord;

         if (ch == '\n')
            return ch;
         else if (char.IsWhiteSpace(ch))
             return yylex();
         else if (char.IsDigit(ch))
         {
             yylval.cVal = ch;
             return (int)Tokens.DIGIT;
         }
         else if ((ch >= 'a' && ch <= 'z') ||
                  (ch >= 'A' && ch <= 'Z'))
         {
            yylval.iVal = char.ToLower(ch) - 'a';
            return (int)Tokens.LETTER;
         }
         else
             switch (ch)
             {
                 case '.':
                 case '+':
                 case '-':
                 case '*':
                 case '/':
                 case '(':
                 case ')':
                 case '%':
                 case '=':
                     return ch;
                 default:
                     Console.Error.WriteLine("Illegal character '{0}'", ch);
                     return yylex();
             }
     }

     public override void yyerror(string format, params object[] args)
     {
         Console.Error.WriteLine(format, args);
     }
}
}
